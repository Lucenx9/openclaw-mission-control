/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Mission Control API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  GatewayModelSyncResult,
  HTTPValidationError,
  ListModelsApiV1ModelRegistryModelsGetParams,
  ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
  LlmModelCreate,
  LlmModelRead,
  LlmModelUpdate,
  LlmProviderAuthCreate,
  LlmProviderAuthRead,
  LlmProviderAuthUpdate,
  OkResponse,
} from ".././model";

import { customFetch } from "../../mutator";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List provider auth records for the active organization.
 * @summary List Provider Auth
 */
export type listProviderAuthApiV1ModelRegistryProviderAuthGetResponse200 = {
  data: LlmProviderAuthRead[];
  status: 200;
};

export type listProviderAuthApiV1ModelRegistryProviderAuthGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listProviderAuthApiV1ModelRegistryProviderAuthGetResponseSuccess =
  listProviderAuthApiV1ModelRegistryProviderAuthGetResponse200 & {
    headers: Headers;
  };
export type listProviderAuthApiV1ModelRegistryProviderAuthGetResponseError =
  listProviderAuthApiV1ModelRegistryProviderAuthGetResponse422 & {
    headers: Headers;
  };

export type listProviderAuthApiV1ModelRegistryProviderAuthGetResponse =
  | listProviderAuthApiV1ModelRegistryProviderAuthGetResponseSuccess
  | listProviderAuthApiV1ModelRegistryProviderAuthGetResponseError;

export const getListProviderAuthApiV1ModelRegistryProviderAuthGetUrl = (
  params?: ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/model-registry/provider-auth?${stringifiedParams}`
    : `/api/v1/model-registry/provider-auth`;
};

export const listProviderAuthApiV1ModelRegistryProviderAuthGet = async (
  params?: ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
  options?: RequestInit,
): Promise<listProviderAuthApiV1ModelRegistryProviderAuthGetResponse> => {
  return customFetch<listProviderAuthApiV1ModelRegistryProviderAuthGetResponse>(
    getListProviderAuthApiV1ModelRegistryProviderAuthGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListProviderAuthApiV1ModelRegistryProviderAuthGetQueryKey = (
  params?: ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
) => {
  return [
    `/api/v1/model-registry/provider-auth`,
    ...(params ? [params] : []),
  ] as const;
};

export const getListProviderAuthApiV1ModelRegistryProviderAuthGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
    >,
    TError = HTTPValidationError,
  >(
    params?: ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getListProviderAuthApiV1ModelRegistryProviderAuthGetQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
      >
    > = ({ signal }) =>
      listProviderAuthApiV1ModelRegistryProviderAuthGet(params, {
        signal,
        ...requestOptions,
      });

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type ListProviderAuthApiV1ModelRegistryProviderAuthGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
    >
  >;
export type ListProviderAuthApiV1ModelRegistryProviderAuthGetQueryError =
  HTTPValidationError;

export function useListProviderAuthApiV1ModelRegistryProviderAuthGet<
  TData = Awaited<
    ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
  >,
  TError = HTTPValidationError,
>(
  params: undefined | ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListProviderAuthApiV1ModelRegistryProviderAuthGet<
  TData = Awaited<
    ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
  >,
  TError = HTTPValidationError,
>(
  params?: ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListProviderAuthApiV1ModelRegistryProviderAuthGet<
  TData = Awaited<
    ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
  >,
  TError = HTTPValidationError,
>(
  params?: ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Provider Auth
 */

export function useListProviderAuthApiV1ModelRegistryProviderAuthGet<
  TData = Awaited<
    ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
  >,
  TError = HTTPValidationError,
>(
  params?: ListProviderAuthApiV1ModelRegistryProviderAuthGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listProviderAuthApiV1ModelRegistryProviderAuthGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getListProviderAuthApiV1ModelRegistryProviderAuthGetQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a provider auth record and sync gateway config.
 * @summary Create Provider Auth
 */
export type createProviderAuthApiV1ModelRegistryProviderAuthPostResponse200 = {
  data: LlmProviderAuthRead;
  status: 200;
};

export type createProviderAuthApiV1ModelRegistryProviderAuthPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type createProviderAuthApiV1ModelRegistryProviderAuthPostResponseSuccess =
  createProviderAuthApiV1ModelRegistryProviderAuthPostResponse200 & {
    headers: Headers;
  };
export type createProviderAuthApiV1ModelRegistryProviderAuthPostResponseError =
  createProviderAuthApiV1ModelRegistryProviderAuthPostResponse422 & {
    headers: Headers;
  };

export type createProviderAuthApiV1ModelRegistryProviderAuthPostResponse =
  | createProviderAuthApiV1ModelRegistryProviderAuthPostResponseSuccess
  | createProviderAuthApiV1ModelRegistryProviderAuthPostResponseError;

export const getCreateProviderAuthApiV1ModelRegistryProviderAuthPostUrl =
  () => {
    return `/api/v1/model-registry/provider-auth`;
  };

export const createProviderAuthApiV1ModelRegistryProviderAuthPost = async (
  llmProviderAuthCreate: LlmProviderAuthCreate,
  options?: RequestInit,
): Promise<createProviderAuthApiV1ModelRegistryProviderAuthPostResponse> => {
  return customFetch<createProviderAuthApiV1ModelRegistryProviderAuthPostResponse>(
    getCreateProviderAuthApiV1ModelRegistryProviderAuthPostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(llmProviderAuthCreate),
    },
  );
};

export const getCreateProviderAuthApiV1ModelRegistryProviderAuthPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createProviderAuthApiV1ModelRegistryProviderAuthPost>
      >,
      TError,
      { data: LlmProviderAuthCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof createProviderAuthApiV1ModelRegistryProviderAuthPost>
    >,
    TError,
    { data: LlmProviderAuthCreate },
    TContext
  > => {
    const mutationKey = [
      "createProviderAuthApiV1ModelRegistryProviderAuthPost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createProviderAuthApiV1ModelRegistryProviderAuthPost>
      >,
      { data: LlmProviderAuthCreate }
    > = (props) => {
      const { data } = props ?? {};

      return createProviderAuthApiV1ModelRegistryProviderAuthPost(
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateProviderAuthApiV1ModelRegistryProviderAuthPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof createProviderAuthApiV1ModelRegistryProviderAuthPost>
    >
  >;
export type CreateProviderAuthApiV1ModelRegistryProviderAuthPostMutationBody =
  LlmProviderAuthCreate;
export type CreateProviderAuthApiV1ModelRegistryProviderAuthPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Provider Auth
 */
export const useCreateProviderAuthApiV1ModelRegistryProviderAuthPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createProviderAuthApiV1ModelRegistryProviderAuthPost>
      >,
      TError,
      { data: LlmProviderAuthCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof createProviderAuthApiV1ModelRegistryProviderAuthPost>
  >,
  TError,
  { data: LlmProviderAuthCreate },
  TContext
> => {
  return useMutation(
    getCreateProviderAuthApiV1ModelRegistryProviderAuthPostMutationOptions(
      options,
    ),
    queryClient,
  );
};
/**
 * Patch a provider auth record and sync gateway config.
 * @summary Update Provider Auth
 */
export type updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponse200 =
  {
    data: LlmProviderAuthRead;
    status: 200;
  };

export type updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponseSuccess =
  updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponse200 & {
    headers: Headers;
  };
export type updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponseError =
  updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponse422 & {
    headers: Headers;
  };

export type updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponse =

    | updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponseSuccess
    | updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponseError;

export const getUpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchUrl =
  (providerAuthId: string) => {
    return `/api/v1/model-registry/provider-auth/${providerAuthId}`;
  };

export const updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch =
  async (
    providerAuthId: string,
    llmProviderAuthUpdate: LlmProviderAuthUpdate,
    options?: RequestInit,
  ): Promise<updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponse> => {
    return customFetch<updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchResponse>(
      getUpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchUrl(
        providerAuthId,
      ),
      {
        ...options,
        method: "PATCH",
        headers: { "Content-Type": "application/json", ...options?.headers },
        body: JSON.stringify(llmProviderAuthUpdate),
      },
    );
  };

export const getUpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch
        >
      >,
      TError,
      { providerAuthId: string; data: LlmProviderAuthUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch
      >
    >,
    TError,
    { providerAuthId: string; data: LlmProviderAuthUpdate },
    TContext
  > => {
    const mutationKey = [
      "updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch
        >
      >,
      { providerAuthId: string; data: LlmProviderAuthUpdate }
    > = (props) => {
      const { providerAuthId, data } = props ?? {};

      return updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch(
        providerAuthId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch
      >
    >
  >;
export type UpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchMutationBody =
  LlmProviderAuthUpdate;
export type UpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchMutationError =
  HTTPValidationError;

/**
 * @summary Update Provider Auth
 */
export const useUpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch
          >
        >,
        TError,
        { providerAuthId: string; data: LlmProviderAuthUpdate },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof updateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatch
      >
    >,
    TError,
    { providerAuthId: string; data: LlmProviderAuthUpdate },
    TContext
  > => {
    return useMutation(
      getUpdateProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdPatchMutationOptions(
        options,
      ),
      queryClient,
    );
  };
/**
 * Delete a provider auth record and sync gateway config.
 * @summary Delete Provider Auth
 */
export type deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponse200 =
  {
    data: OkResponse;
    status: 200;
  };

export type deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponseSuccess =
  deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponse200 & {
    headers: Headers;
  };
export type deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponseError =
  deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponse422 & {
    headers: Headers;
  };

export type deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponse =

    | deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponseSuccess
    | deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponseError;

export const getDeleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteUrl =
  (providerAuthId: string) => {
    return `/api/v1/model-registry/provider-auth/${providerAuthId}`;
  };

export const deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete =
  async (
    providerAuthId: string,
    options?: RequestInit,
  ): Promise<deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponse> => {
    return customFetch<deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteResponse>(
      getDeleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteUrl(
        providerAuthId,
      ),
      {
        ...options,
        method: "DELETE",
      },
    );
  };

export const getDeleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete
        >
      >,
      TError,
      { providerAuthId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete
      >
    >,
    TError,
    { providerAuthId: string },
    TContext
  > => {
    const mutationKey = [
      "deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete
        >
      >,
      { providerAuthId: string }
    > = (props) => {
      const { providerAuthId } = props ?? {};

      return deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete(
        providerAuthId,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete
      >
    >
  >;

export type DeleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Provider Auth
 */
export const useDeleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete
          >
        >,
        TError,
        { providerAuthId: string },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof deleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDelete
      >
    >,
    TError,
    { providerAuthId: string },
    TContext
  > => {
    return useMutation(
      getDeleteProviderAuthApiV1ModelRegistryProviderAuthProviderAuthIdDeleteMutationOptions(
        options,
      ),
      queryClient,
    );
  };
/**
 * List gateway model catalog entries for the active organization.
 * @summary List Models
 */
export type listModelsApiV1ModelRegistryModelsGetResponse200 = {
  data: LlmModelRead[];
  status: 200;
};

export type listModelsApiV1ModelRegistryModelsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listModelsApiV1ModelRegistryModelsGetResponseSuccess =
  listModelsApiV1ModelRegistryModelsGetResponse200 & {
    headers: Headers;
  };
export type listModelsApiV1ModelRegistryModelsGetResponseError =
  listModelsApiV1ModelRegistryModelsGetResponse422 & {
    headers: Headers;
  };

export type listModelsApiV1ModelRegistryModelsGetResponse =
  | listModelsApiV1ModelRegistryModelsGetResponseSuccess
  | listModelsApiV1ModelRegistryModelsGetResponseError;

export const getListModelsApiV1ModelRegistryModelsGetUrl = (
  params?: ListModelsApiV1ModelRegistryModelsGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/model-registry/models?${stringifiedParams}`
    : `/api/v1/model-registry/models`;
};

export const listModelsApiV1ModelRegistryModelsGet = async (
  params?: ListModelsApiV1ModelRegistryModelsGetParams,
  options?: RequestInit,
): Promise<listModelsApiV1ModelRegistryModelsGetResponse> => {
  return customFetch<listModelsApiV1ModelRegistryModelsGetResponse>(
    getListModelsApiV1ModelRegistryModelsGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListModelsApiV1ModelRegistryModelsGetQueryKey = (
  params?: ListModelsApiV1ModelRegistryModelsGetParams,
) => {
  return [
    `/api/v1/model-registry/models`,
    ...(params ? [params] : []),
  ] as const;
};

export const getListModelsApiV1ModelRegistryModelsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListModelsApiV1ModelRegistryModelsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListModelsApiV1ModelRegistryModelsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>
  > = ({ signal }) =>
    listModelsApiV1ModelRegistryModelsGet(params, {
      signal,
      ...requestOptions,
    });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListModelsApiV1ModelRegistryModelsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>
>;
export type ListModelsApiV1ModelRegistryModelsGetQueryError =
  HTTPValidationError;

export function useListModelsApiV1ModelRegistryModelsGet<
  TData = Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | ListModelsApiV1ModelRegistryModelsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
          TError,
          Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListModelsApiV1ModelRegistryModelsGet<
  TData = Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListModelsApiV1ModelRegistryModelsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
          TError,
          Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListModelsApiV1ModelRegistryModelsGet<
  TData = Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListModelsApiV1ModelRegistryModelsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Models
 */

export function useListModelsApiV1ModelRegistryModelsGet<
  TData = Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListModelsApiV1ModelRegistryModelsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listModelsApiV1ModelRegistryModelsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListModelsApiV1ModelRegistryModelsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a model catalog entry and sync gateway config.
 * @summary Create Model
 */
export type createModelApiV1ModelRegistryModelsPostResponse200 = {
  data: LlmModelRead;
  status: 200;
};

export type createModelApiV1ModelRegistryModelsPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type createModelApiV1ModelRegistryModelsPostResponseSuccess =
  createModelApiV1ModelRegistryModelsPostResponse200 & {
    headers: Headers;
  };
export type createModelApiV1ModelRegistryModelsPostResponseError =
  createModelApiV1ModelRegistryModelsPostResponse422 & {
    headers: Headers;
  };

export type createModelApiV1ModelRegistryModelsPostResponse =
  | createModelApiV1ModelRegistryModelsPostResponseSuccess
  | createModelApiV1ModelRegistryModelsPostResponseError;

export const getCreateModelApiV1ModelRegistryModelsPostUrl = () => {
  return `/api/v1/model-registry/models`;
};

export const createModelApiV1ModelRegistryModelsPost = async (
  llmModelCreate: LlmModelCreate,
  options?: RequestInit,
): Promise<createModelApiV1ModelRegistryModelsPostResponse> => {
  return customFetch<createModelApiV1ModelRegistryModelsPostResponse>(
    getCreateModelApiV1ModelRegistryModelsPostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(llmModelCreate),
    },
  );
};

export const getCreateModelApiV1ModelRegistryModelsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createModelApiV1ModelRegistryModelsPost>>,
    TError,
    { data: LlmModelCreate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createModelApiV1ModelRegistryModelsPost>>,
  TError,
  { data: LlmModelCreate },
  TContext
> => {
  const mutationKey = ["createModelApiV1ModelRegistryModelsPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createModelApiV1ModelRegistryModelsPost>>,
    { data: LlmModelCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createModelApiV1ModelRegistryModelsPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateModelApiV1ModelRegistryModelsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createModelApiV1ModelRegistryModelsPost>>
>;
export type CreateModelApiV1ModelRegistryModelsPostMutationBody =
  LlmModelCreate;
export type CreateModelApiV1ModelRegistryModelsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Model
 */
export const useCreateModelApiV1ModelRegistryModelsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createModelApiV1ModelRegistryModelsPost>>,
      TError,
      { data: LlmModelCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createModelApiV1ModelRegistryModelsPost>>,
  TError,
  { data: LlmModelCreate },
  TContext
> => {
  return useMutation(
    getCreateModelApiV1ModelRegistryModelsPostMutationOptions(options),
    queryClient,
  );
};
/**
 * Patch a model catalog entry and sync gateway config.
 * @summary Update Model
 */
export type updateModelApiV1ModelRegistryModelsModelIdPatchResponse200 = {
  data: LlmModelRead;
  status: 200;
};

export type updateModelApiV1ModelRegistryModelsModelIdPatchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updateModelApiV1ModelRegistryModelsModelIdPatchResponseSuccess =
  updateModelApiV1ModelRegistryModelsModelIdPatchResponse200 & {
    headers: Headers;
  };
export type updateModelApiV1ModelRegistryModelsModelIdPatchResponseError =
  updateModelApiV1ModelRegistryModelsModelIdPatchResponse422 & {
    headers: Headers;
  };

export type updateModelApiV1ModelRegistryModelsModelIdPatchResponse =
  | updateModelApiV1ModelRegistryModelsModelIdPatchResponseSuccess
  | updateModelApiV1ModelRegistryModelsModelIdPatchResponseError;

export const getUpdateModelApiV1ModelRegistryModelsModelIdPatchUrl = (
  modelId: string,
) => {
  return `/api/v1/model-registry/models/${modelId}`;
};

export const updateModelApiV1ModelRegistryModelsModelIdPatch = async (
  modelId: string,
  llmModelUpdate: LlmModelUpdate,
  options?: RequestInit,
): Promise<updateModelApiV1ModelRegistryModelsModelIdPatchResponse> => {
  return customFetch<updateModelApiV1ModelRegistryModelsModelIdPatchResponse>(
    getUpdateModelApiV1ModelRegistryModelsModelIdPatchUrl(modelId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(llmModelUpdate),
    },
  );
};

export const getUpdateModelApiV1ModelRegistryModelsModelIdPatchMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateModelApiV1ModelRegistryModelsModelIdPatch>
      >,
      TError,
      { modelId: string; data: LlmModelUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof updateModelApiV1ModelRegistryModelsModelIdPatch>>,
    TError,
    { modelId: string; data: LlmModelUpdate },
    TContext
  > => {
    const mutationKey = ["updateModelApiV1ModelRegistryModelsModelIdPatch"];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateModelApiV1ModelRegistryModelsModelIdPatch>
      >,
      { modelId: string; data: LlmModelUpdate }
    > = (props) => {
      const { modelId, data } = props ?? {};

      return updateModelApiV1ModelRegistryModelsModelIdPatch(
        modelId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateModelApiV1ModelRegistryModelsModelIdPatchMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateModelApiV1ModelRegistryModelsModelIdPatch>>
  >;
export type UpdateModelApiV1ModelRegistryModelsModelIdPatchMutationBody =
  LlmModelUpdate;
export type UpdateModelApiV1ModelRegistryModelsModelIdPatchMutationError =
  HTTPValidationError;

/**
 * @summary Update Model
 */
export const useUpdateModelApiV1ModelRegistryModelsModelIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateModelApiV1ModelRegistryModelsModelIdPatch>
      >,
      TError,
      { modelId: string; data: LlmModelUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateModelApiV1ModelRegistryModelsModelIdPatch>>,
  TError,
  { modelId: string; data: LlmModelUpdate },
  TContext
> => {
  return useMutation(
    getUpdateModelApiV1ModelRegistryModelsModelIdPatchMutationOptions(options),
    queryClient,
  );
};
/**
 * Delete a model catalog entry and sync gateway config.
 * @summary Delete Model
 */
export type deleteModelApiV1ModelRegistryModelsModelIdDeleteResponse200 = {
  data: OkResponse;
  status: 200;
};

export type deleteModelApiV1ModelRegistryModelsModelIdDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deleteModelApiV1ModelRegistryModelsModelIdDeleteResponseSuccess =
  deleteModelApiV1ModelRegistryModelsModelIdDeleteResponse200 & {
    headers: Headers;
  };
export type deleteModelApiV1ModelRegistryModelsModelIdDeleteResponseError =
  deleteModelApiV1ModelRegistryModelsModelIdDeleteResponse422 & {
    headers: Headers;
  };

export type deleteModelApiV1ModelRegistryModelsModelIdDeleteResponse =
  | deleteModelApiV1ModelRegistryModelsModelIdDeleteResponseSuccess
  | deleteModelApiV1ModelRegistryModelsModelIdDeleteResponseError;

export const getDeleteModelApiV1ModelRegistryModelsModelIdDeleteUrl = (
  modelId: string,
) => {
  return `/api/v1/model-registry/models/${modelId}`;
};

export const deleteModelApiV1ModelRegistryModelsModelIdDelete = async (
  modelId: string,
  options?: RequestInit,
): Promise<deleteModelApiV1ModelRegistryModelsModelIdDeleteResponse> => {
  return customFetch<deleteModelApiV1ModelRegistryModelsModelIdDeleteResponse>(
    getDeleteModelApiV1ModelRegistryModelsModelIdDeleteUrl(modelId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getDeleteModelApiV1ModelRegistryModelsModelIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteModelApiV1ModelRegistryModelsModelIdDelete>
      >,
      TError,
      { modelId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteModelApiV1ModelRegistryModelsModelIdDelete>
    >,
    TError,
    { modelId: string },
    TContext
  > => {
    const mutationKey = ["deleteModelApiV1ModelRegistryModelsModelIdDelete"];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteModelApiV1ModelRegistryModelsModelIdDelete>
      >,
      { modelId: string }
    > = (props) => {
      const { modelId } = props ?? {};

      return deleteModelApiV1ModelRegistryModelsModelIdDelete(
        modelId,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteModelApiV1ModelRegistryModelsModelIdDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteModelApiV1ModelRegistryModelsModelIdDelete>>
  >;

export type DeleteModelApiV1ModelRegistryModelsModelIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Model
 */
export const useDeleteModelApiV1ModelRegistryModelsModelIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteModelApiV1ModelRegistryModelsModelIdDelete>
      >,
      TError,
      { modelId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteModelApiV1ModelRegistryModelsModelIdDelete>>,
  TError,
  { modelId: string },
  TContext
> => {
  return useMutation(
    getDeleteModelApiV1ModelRegistryModelsModelIdDeleteMutationOptions(options),
    queryClient,
  );
};
/**
 * Push provider auth + model catalog + agent model links to a gateway.
 * @summary Sync Gateway Models
 */
export type syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponse200 =
  {
    data: GatewayModelSyncResult;
    status: 200;
  };

export type syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponseSuccess =
  syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponse200 & {
    headers: Headers;
  };
export type syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponseError =
  syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponse422 & {
    headers: Headers;
  };

export type syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponse =

    | syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponseSuccess
    | syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponseError;

export const getSyncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostUrl =
  (gatewayId: string) => {
    return `/api/v1/model-registry/gateways/${gatewayId}/sync`;
  };

export const syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost =
  async (
    gatewayId: string,
    options?: RequestInit,
  ): Promise<syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponse> => {
    return customFetch<syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostResponse>(
      getSyncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostUrl(
        gatewayId,
      ),
      {
        ...options,
        method: "POST",
      },
    );
  };

export const getSyncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost
        >
      >,
      TError,
      { gatewayId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost
      >
    >,
    TError,
    { gatewayId: string },
    TContext
  > => {
    const mutationKey = [
      "syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost
        >
      >,
      { gatewayId: string }
    > = (props) => {
      const { gatewayId } = props ?? {};

      return syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost(
        gatewayId,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type SyncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost
      >
    >
  >;

export type SyncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostMutationError =
  HTTPValidationError;

/**
 * @summary Sync Gateway Models
 */
export const useSyncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost
        >
      >,
      TError,
      { gatewayId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<
      typeof syncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPost
    >
  >,
  TError,
  { gatewayId: string },
  TContext
> => {
  return useMutation(
    getSyncGatewayModelsApiV1ModelRegistryGatewaysGatewayIdSyncPostMutationOptions(
      options,
    ),
    queryClient,
  );
};
